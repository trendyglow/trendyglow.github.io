---
title : "[Algorithms] Big O ë¡œê·¸ì™€ ì„¸ì…˜ ìš”ì•½"
layout: single
excerpt: "Big O ì•Œê³ ë¦¬ì¦˜ in JS - 3"
toc: true
toc_sticky: true
date: 2022-12-20
categories: [Algorithm]
tag: [Big O]
author_profile: false
header:
  overlay_image: assets/images/header_post_1.jpg
  overlay_filter: 0.5 
  teaser: assets/images/Algorithm.png
use_math: true
---  

> ì´ì „ê¸€  
: [Big O ì•Œê³ ë¦¬ì¦˜ in JS - 1](https://sun0te.github.io/algorithm/BigO/)  
[Big O ì•Œê³ ë¦¬ì¦˜ in JS - 2](https://sun0te.github.io/algorithm/BigO_2/)  

---

# Logarithms  
We've encountered some of the most common complexities : $O(1)$, $O(n)$, $O(n^2)$  
$O(1)$, $O(n)$, $O(n^2)$ ì²˜ëŸ¼ ë¹…ì˜¤ê°€ ê°„ë‹¨í•˜ì§€ ì•ŠëŠ” ê²½ìš°ê°€ ìˆë‹¤.  

Sometimes big O expressions involve more complex mathematical expressions  
ë¹…ì˜¤ í‘œê¸°ë“¤ ì¤‘ì— ë” ì–´ë µê±°ë‚˜ ëœ í”í•œ ìˆ˜í•™ ê°œë…ë“¤ë„ í¬í•¨ë˜ì–´ ìˆì„ ìˆ˜ ìˆë‹¤.  

One that appears more often than you might like is the logrithm  
ê·¸ ì¤‘ì— ìì£¼ ë‚˜ì˜¤ëŠ” ê°œë…ì´ ë¡œê·¸ì´ë‹¤.  

## ë¡œê·¸í•¨ìˆ˜
ë¡œê·¸í•¨ìˆ˜ëŠ” ì§€ìˆ˜í•¨ìˆ˜ì˜ ì—­í• ì´ë‹¤.  
ë‚˜ëˆ—ì…ˆê³¼ ê³±ì…ˆì´ ì§ì¸ê²ƒì²˜ëŸ¼ ë¡œê·¸í•¨ìˆ˜ì™€ ì§€ìˆ˜í•©ìˆ˜ëŠ” ì§ì´ ëœë‹¤.  

**$log_2(8) = 3$Â  Â  Â â†’Â  Â  Â $2^3 = 8$**

2ë¥¼ ë°‘ìœ¼ë¡œ í•˜ëŠ” ì–´ë–¤ ê°’ì˜ ë¡œê·¸ëŠ” ì–´ë–¤ ì§€ìˆ˜ê°’ê³¼ ê°™ë‹¤.  

**$log_2(value) = e$Â  Â  Â â†’Â  Â  Â $2^e = value$**

We'll omit the 2.  
í•´ë‹¹ ê¸€ì—ì„œëŠ” ì „ì²´ì ìœ¼ë¡œ í° í‹€ì— ì‹ ê²½ì“°ê¸° ë•Œë¬¸ì— 2ëŠ” ìƒëµí•˜ê³  ê·¸ëƒ¥ logë¼ê³  í•œë‹¤.  
$log === log_2$   

## logarithm Example ğŸ“  

> **\* rule of thumb**  
The logarithm of a number roughly measures the number of times your can divide that number by 2 **before your get a value that's less than or equal to one.**  
ê°„ë‹¨í•œ ê·œì¹™ìœ¼ë¡œ, ì–´ë–¤ ì´ì§„ ë¡œê·¸ë¥¼ ëŒ€ëµ ê³„ì‚°í•˜ê¸° ìœ„í•´ì„œëŠ”  
ê·¸ ìˆ«ìê°€ 1ë³´ë‹¤ ì‘ì•„ì§€ê¸° ì „ì— 2ë¡œ ë‚˜ëˆ ì§€ëŠ” íšŸìˆ˜ì´ë‹¤.  
{: .notice}

<center><img src="/images/2022-12-13-BigO/logarithm.png"></center>  
ì‹¤ì œ ê³„ì‚°ì´ ì¤‘ìš”í•˜ì§€ëŠ” ì•Šë‹¤.  
ì¤‘ìš”í•œ ê²ƒì€ ê·¸ë˜í”„ì—ì„œ ì–´ë–¨ê²Œ ë³´ì´ëŠ”ì§€ì´ë‹¤.  

## logarithm Complexity ğŸ“ˆ  
ì•„ë˜ì˜ ê·¸ë˜í”„ë¥¼ ë³´ë©´ ì•Œë‹¤ì‹œí”¼ ë¡œê·¸ ì‹œê°„ ë³µì¡ë„ëŠ” ì•„ì£¼ ì¢‹ë‹¤.  


> **Big O Time Complexity**  <center><img src="/images/2022-12-13-BigO/BigO_graph.png"></center>
{: .notice}

## ë¡œê·¸ì™€ ê´€ë ¨ìˆëŠ” ê²ƒë“¤
- Certain searching algorithms have logarithmic time complexity.  
ì–´ë–¤ `íƒìƒ‰ ì•Œê³ ë¦¬ì¦˜`ë“¤ì€ ë¡œê·¸ ì‹œê°„ ë³µì¡ë„ë¥¼ ê°€ì§€ê³  ìˆë‹¤.  

- Efficient sorting alforithms involve logarithms.  
íš¨ìœ¨ì ì¸ `ì •ë ¬ ì•Œê³ ë¦¬ì¦˜`ë“¤ë„ ë¡œê·¸ì™€ ê´€ë ¨ë˜ì–´ ìˆë‹¤.  

- Recursion sometimes involves logarithmic space complexity.  
 `ì¬ê·€`(å†æ­¸)ë„ ë•Œë•Œë¡œ ë¡œê·¸ ê³µê°„ ë³µì¡ë„ë¥¼ í¬í•¨í•œë‹¤.  

## Big O ì•Œê³ ë¦¬ì¦˜ ì´ ì •ë¦¬
- To analyze the performance of an algorithm, we use Big O Notation  
ì•Œê³ ë¦¬ì¦˜ ì„±ëŠ¥ì„ ë¶„ì„í•˜ê¸° ìœ„í•´ì„œ Big O í‘œê¸°ë²•ì„ ì‚¬ìš©í•œë‹¤.  

- Big O Notation can give us a high level understanding of the time or space complexity of an algorithm  
ë¹…ì˜¤ë¥¼ í†µí•´ì„œ ì‹œê°„ê³¼ ê³µê°„ ë³µì¡ë„ì— ëŒ€í•œ ì´í•´ë¥¼ ë†’ì¼ ìˆ˜ ìˆë‹¤.  

- Big O Notation doesn't care about precision, only about general trends (*lenear? quadratic? constant?*)  
ë¹…ì˜¤ í‘œê¸°ë²•ì€ ì •í™•ë„ê°€ ì•„ë‹ˆë¼ ì „ì²´ì ì¸ ì¶”ì„¸ë¥¼ ì¤‘ìš”í•˜ê²Œ ì—¬ê¸´ë‹¤.  

- The time or space complexity (as measured by Big O) depends only on the algorithm, not the hardware used to run the algorithm  
ë¹…ì˜¤ë¡œ ì¸¡ì •ë˜ëŠ” ì•Œê³ ë¦¬ì¦˜ì˜ ì‹œê°„ê³¼ ê³µê°„ ë³µì¡ë„ëŠ” í•˜ë“œì›¨ì–´ì— ì˜í–¥ì„ ë°›ì§€ ì•ŠëŠ”ë‹¤.  
ì°¨ì´ê°€ ìˆì„ ìˆ˜ ìˆìœ¼ë‚˜ ì „ë°˜ì ì¸ ì¶”ì„¸ëŠ” ë‹¤ë¥´ì§€ ì•Šë‹¤.  
ë¹…ì˜¤ëŠ” ì‹¤í–‰ë  ì—°ì‚°ì˜ ê°¯ìˆ˜ë¥¼ ë”°ì§€ê¸° ë•Œë¬¸ì´ë‹¤.  

ğŸŒ ì •ë³´ : ê³µë¶€ ê¸°ë¡ìš© ë¸”ë¡œê·¸ì…ë‹ˆë‹¤. ì˜¤íƒ€ë‚˜ ë‚´ìš© ì˜¤ë¥˜ê°€ ìˆì„ ê²½ìš° ì•Œë ¤ì£¼ì‹œë©´ ê°ì‚¬í•˜ê² ìŠµë‹ˆë‹¤.
{: .notice}
